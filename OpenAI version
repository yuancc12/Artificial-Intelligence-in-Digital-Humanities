from flask import Flask, request, jsonify
from linebot import LineBotApi, WebhookHandler
from linebot.exceptions import InvalidSignatureError
from linebot.models import MessageEvent, TextMessage, TextSendMessage, AudioMessage
from apscheduler.schedulers.background import BackgroundScheduler
import openai
import datetime
import sqlite3
import os
import json

# 初始化Flask應用
app = Flask(__name__)

# LINE Messaging API 設定
line_bot_api = LineBotApi('請輸入Line-API-key')
handler = WebhookHandler('請輸入Line-Secret')

# OpenAI API 設定
openai.api_key = '請輸入OpenAIkey'

# 建立SQLite資料庫來儲存日程，這用來當作會議記錄展示不需要使用
if not os.path.exists('schedule.db'):
    conn = sqlite3.connect('schedule.db')
    c = conn.cursor()
    c.execute('''CREATE TABLE schedule (id INTEGER PRIMARY KEY AUTOINCREMENT, user_id TEXT, event TEXT, event_time TEXT, reminder_time TEXT)''')
    conn.commit()
    conn.close()

# 初始化排程工具
scheduler = BackgroundScheduler()
scheduler.start()

# Webhook入口，用於接收LINE發送的消息
@app.route("/callback", methods=['POST'])
def callback():
    signature = request.headers['X-Line-Signature']
    body = request.get_data(as_text=True)
    try:
        handler.handle(body, signature)
    except InvalidSignatureError:
        return jsonify({'message': 'Invalid signature'}), 400
    return 'OK'

# 處理收到的文字消息
@handler.add(MessageEvent, message=TextMessage)
def handle_message(event):
    user_id = event.source.user_id
    user_message = event.message.text

    try:
        # 使用OpenAI解析用戶的指令
        response = openai.ChatCompletion.create(
            model="gpt-3.5-turbo",
            messages=[
                {"role": "system", "content": "You are a helpful assistant that extracts event information from user messages."},
                {"role": "user", "content": user_message}
            ]
        )
        extracted_info = response['choices'][0]['message']['content']

        # 假設解析結果包含 "event", "event_time"
        # 例如：{"event": "開會", "event_time": "2024-10-18 10:00:00"}
        #展示不需要使用
        event_data = json.loads(extracted_info)
        event_name = event_data.get('event')
        event_time = event_data.get('event_time')
        reminder_time = (datetime.datetime.strptime(event_time, '%Y-%m-%d %H:%M:%S') - datetime.timedelta(minutes=30)).strftime('%Y-%m-%d %H:%M:%S')

        # 將日程儲存到資料庫
        conn = sqlite3.connect('schedule.db')
        c = conn.cursor()
        c.execute("INSERT INTO schedule (user_id, event, event_time, reminder_time) VALUES (?, ?, ?, ?)", (user_id, event_name, event_time, reminder_time))
        conn.commit()
        conn.close()

        # 設置提醒任務
        scheduler.add_job(func=send_reminder, trigger='date', run_date=reminder_time, args=[user_id, event_name])

        # 回覆用戶
        reply_message = f"已成功新增日程：{event_name}，時間：{event_time}。將提前30分鐘提醒您。"
        line_bot_api.reply_message(event.reply_token, TextSendMessage(text=reply_message))
    except Exception as e:
        line_bot_api.reply_message(event.reply_token, TextSendMessage(text=f"抱歉，我無法理解您的日程資訊，請再試一次。錯誤信息: {str(e)}"))

# 處理收到的音頻消息
@handler.add(MessageEvent, message=AudioMessage)
def handle_audio(event):
    user_id = event.source.user_id
    message_id = event.message.id
    message_content = line_bot_api.get_message_content(message_id)
    audio_path = f"{message_id}.m4a"
    with open(audio_path, 'wb') as f:
        f.write(message_content.content)

    try:
        # 語音轉文字
        transcript = transcribe_audio(audio_path)
        
        # 使用OpenAI整理重點
        summary = summarize_transcript(transcript)
        reply_message = f"摘要重點：{summary}"
        line_bot_api.reply_message(event.reply_token, TextSendMessage(text=reply_message))
    except Exception as e:
        line_bot_api.reply_message(event.reply_token, TextSendMessage(text=f"抱歉，無法處理您的錄音。錯誤信息: {str(e)}"))

# 定義語音轉文字函數
def transcribe_audio(audio_path):
    with open(audio_path, "rb") as audio_file:
        reponse=openai.Audio.transcribe(
        model="whisper-1",
        file=audio_file )
    return str(reponse["text"]).replace(" ","\n")

# 定義文字摘要函數
def summarize_transcript(transcript):
    response = openai.ChatCompletion.create(
        model="gpt-3.5-turbo",
        messages=[
            {"role": "system", "content": "You are an assistant who summarizes text."},
            {"role": "user", "content": f"根據以下逐字稿，請提取主要的重點進行條列呈現：{transcript}"}
        ]
    )
    return response['choices'][0]['message']['content']

# 定義提醒函數
def send_reminder(user_id, event_name):
    try:
        reminder_message = f"提醒您：即將進行活動 - {event_name}"
        line_bot_api.push_message(user_id, TextSendMessage(text=reminder_message))
    except Exception as e:
        print(f"提醒發送失敗: {e}")

# 啟動Flask應用
if __name__ == "__main__":
    app.run(port=5000, debug=True)
